(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["2d230cc3"],{ee8e:function(i,l,t){"use strict";t.r(l);var v=function(){var i=this,l=i.$createElement;i._self._c;return i._m(0)},e=[function(){var i=this,l=i.$createElement,t=i._self._c||l;return t("div",[t("h1",[i._v("git")]),t("h2",[i._v("git工作流程")]),t("h3",[i._v("工作流程")]),t("h2",[i._v("git常用操作命令")]),t("h3",[i._v("git创建仓库")]),t("ul",[t("li",[t("p",[i._v("git init")])]),t("li",[t("p",[i._v("git clone")]),t("p",[i._v("格式：")]),t("p",[i._v("git clonerepo [directory]")]),t("p",[i._v("参数说明：")]),t("p",[i._v("repo:Git 仓库。")]),t("p",[i._v("directory:本地目录。")])])]),t("h3",[i._v("git基本操作")]),t("ul",[t("li",[t("p",[i._v("获取与创建项目命令")]),t("ul",[t("li",[i._v("git init")]),t("li",[i._v("git clone")])])]),t("li",[t("p",[i._v("基本快照")]),t("ul",[t("li",[t("p",[i._v("git add")]),t("p",[i._v("git add 命令可将该文件添加到缓存")])]),t("li",[t("p",[i._v("git status")]),t("p",[i._v("git status 以查看在你上次提交之后是否有修改。")])]),t("li",[t("p",[i._v("git diff")]),t("p",[i._v("执行 git diff 来查看执行 git status 的结果的详细信息。")]),t("p",[i._v(" ")]),t("p",[i._v("尚未缓存的改动：git diff")]),t("p",[i._v("查看已缓存的改动： git diff --cached")]),t("p",[i._v("查看已缓存的与未缓存的所有改动：git diff HEAD")]),t("p",[i._v("显示摘要而非整个 diff：git diff --stat")])]),t("li",[t("p",[i._v("git commit")]),t("p",[i._v("使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。")]),t("p",[i._v(" ")]),t("p",[i._v("注意：常用格式:")]),t("p",[i._v('git commit -m  "content"')])]),t("li",[t("p",[i._v("git reset HEAD")]),t("p",[i._v("git reset HEAD 命令用于取消已缓存的内容。")])]),t("li",[t("p",[i._v("git rm")]),t("p",[i._v("如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。")]),t("p",[i._v(" ")]),t("p",[i._v("要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。")]),t("p",[i._v("git rm file")]),t("p",[i._v(" ")]),t("p",[i._v("如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f")]),t("p",[i._v("git rm -f file")]),t("p",[i._v(" ")]),t("p",[i._v("如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可")]),t("p",[i._v("git rm --cached file")])])])])]),t("h3",[i._v("git 分支管理")]),t("ul",[t("li",[t("p",[i._v("列出分支")]),t("ul",[t("li",[i._v("git branch")])])]),t("li",[t("p",[i._v("切换分支")]),t("ul",[t("li",[i._v("git checkout")])])]),t("li",[t("p",[i._v("创建分支")]),t("ul",[t("li",[t("p",[i._v("git checkout -b (branchname)")]),t("p",[i._v("我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。")])])])]),t("li",[t("p",[i._v("删除分支")]),t("ul",[t("li",[i._v("git branch -d (branchname)")])])]),t("li",[t("p",[i._v("合并分支")]),t("ul",[t("li",[i._v("git merge")])])]),t("li",[t("p",[i._v("合并冲突")])])]),t("h3",[i._v("git查看提交历史")]),t("ul",[t("li",[t("p",[i._v("git log")]),t("p",[i._v("用 --oneline 选项来查看历史记录的简洁的版本。\n$ git log --oneline\n用 --graph 选项，查看历史中什么时候出现了分支、合并。\ngit log --oneline --graph\n你也可以用 '--reverse'参数来逆向显示所有日志\ngit log --reverse --oneline\n指定用户的提交日志可以使用命令：git log --author \ngit log --author=Linus --oneline -5\n如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges")])])]),t("h2",[i._v("Git")]),t("h3",[i._v("Git 设置")]),t("ul",[t("li",[t("p",[i._v("配置 user.name 和 user.email")]),t("ul",[t("li",[t("p",[i._v("命令")]),t("ul",[t("li",[i._v("git config --global user.name 'theon'")]),t("li",[i._v("git config --global user.email 'xien.xiaohongshu.com'")])])]),t("li",[t("p",[i._v("config 的三个作用域")]),t("ul",[t("li",[i._v("--local 只对某个仓库有效")]),t("li",[i._v("--global 对当前用户的所有仓库有效")]),t("li",[i._v("--system 对系统所有登陆的用户有效")])])]),t("li",[t("p",[i._v("显示 config 的配置，加 --list")]),t("ul",[t("li",[i._v("git config --list --local")]),t("li",[i._v("git config --list --global")]),t("li",[i._v("git config --list --system")])])])])]),t("li",[t("p",[i._v(".git 文件解析")]),t("ul",[t("li",[t("p",[i._v("HEAD")]),t("ul",[t("li",[t("p",[i._v("ref: refs/heads/master")]),t("ul",[t("li",[i._v("引用 ：本地仓库 正处于哪个分支 ")])])]),t("li",[t("p",[i._v("不跟任何的分支挂钩 如果处于分离头指针的状态，指向最近的一次 commit")])])])]),t("li",[t("p",[i._v("config ")]),t("ul",[t("li",[i._v("当前工作路径下的 配置信息")])])]),t("li",[t("p",[i._v("refs")]),t("ul",[t("li",[t("p",[i._v("heads")]),t("ul",[t("li",[i._v("落脚于某次 commit")])])]),t("li",[t("p",[i._v("tags (标签/里程碑)")]),t("ul",[t("li",[i._v("使用场景： 记录重要信息 比如 1.0 发版")])])])])]),t("li",[t("p",[i._v("其他命令")]),t("ul",[t("li",[t("p",[i._v("查看 git文件的 类型，使用参数 -t")]),t("ul",[t("li",[i._v("git cat-file -t  80565b73e7d2f0a2b5b9667c0b34")])])]),t("li",[t("p",[i._v("查看  git 文件的内容 参数 -p")]),t("ul",[t("li",[i._v("git cat-file -p  xxxxcommit_hash")])])]),t("li",[t("p",[i._v("查看 文件夹中是否有内容")]),t("ul",[t("li",[i._v("find .git/objects -type f")])])])])])])]),t("li",[t("p",[i._v("git 图形化界面")]),t("ul",[t("li",[t("p",[i._v("查看所有分支的log")]),t("ul",[t("li",[i._v("gitk --all")])])])])])]),t("h3",[i._v("基础")]),t("ul",[t("li",[t("p",[i._v("建立 git 仓库")]),t("ul",[t("li",[t("p",[i._v("把已有本地项目纳入 git 管理")]),t("ul",[t("li",[t("p",[i._v("cd 文件夹")]),t("ul",[t("li",[i._v("git init")])])])])]),t("li",[t("p",[i._v("新建 使用 git 来管理的项目")]),t("ul",[t("li",[t("p",[i._v("cd 文件夹")]),t("ul",[t("li",[t("p",[i._v("git init  my_project ")]),t("ul",[t("li",[i._v("cd my_project")])])])])])])])])]),t("li",[t("p",[i._v("提交")]),t("ul",[t("li",[t("p",[i._v("添加到暂存区")]),t("ul",[t("li",[t("p",[i._v("添加 已经被git跟踪的文件")]),t("ul",[t("li",[i._v("git add -u")])])]),t("li",[t("p",[i._v("添加 指定文件 ")]),t("ul",[t("li",[i._v("git  add styles/style.css")])])])])]),t("li",[t("p",[i._v("从暂存区删除")]),t("ul",[t("li",[i._v("git rm readme")])])]),t("li",[t("p",[i._v("把工作区的内容 直接创建到 版本历史库里面")]),t("ul",[t("li",[i._v("git commit -am'Add test'")])])]),t("li",[t("p",[i._v("清理 当前暂存区的 所有变更")]),t("ul",[t("li",[i._v("git reset --hard")])])]),t("li",[t("p",[i._v("重命名文件")]),t("ul",[t("li",[i._v("git mv readme readme.md")])])]),t("li",[t("p",[i._v("修改 commit 提交信息")]),t("ul",[t("li",[t("p",[i._v("修改最近的一次提交的信息 ")]),t("ul",[t("li",[i._v("git commit --amend")])])]),t("li",[t("p",[i._v("修改任意提交的信息( 变基 )")]),t("ul",[t("li",[t("p",[i._v("git rebase -i commitId (要选择 想更改的这次commit 的父亲级 commitId，作为 commitId)")])]),t("li",[t("p",[i._v("commit 对应的文件  以及文件内容 不会发生变化")]),t("ul",[t("li",[i._v("tree中的 blob 是没有发生变化的")])])]),t("li",[t("p",[i._v("r ,rewrite")]),t("ul",[t("li",[i._v("修改某一次的提交记录")])])]),t("li",[t("p",[i._v("s, squash")]),t("ul",[t("li",[i._v("修改 提交信息 并且合并到上一次提交")])])]),t("li",[t("p",[i._v("ommit 次数不够用时，可以复制 一次父亲级 commitId 放到交互式界面 第一行,让别的记录往里面融合")]),t("ul",[t("li",[i._v("git rebase --continue")])])])])])])])])]),t("li",[t("p",[i._v("查看 版本演变历史")]),t("ul",[t("li",[t("p",[i._v("提交记录")]),t("ul",[t("li",[t("p",[i._v("查看当前分支的历史")]),t("ul",[t("li",[i._v("git log")])])]),t("li",[t("p",[i._v("简洁版 一行显示的 ")]),t("ul",[t("li",[i._v("git log --oneline")]),t("li",[i._v("git log --oneline --all")])])]),t("li",[t("p",[i._v("最近的 n 次提交记录")]),t("ul",[t("li",[i._v("git log -n4 --oneline")]),t("li",[i._v("git  log --oneline --all -n4")])])]),t("li",[t("p",[i._v("查看所有分支的历史")]),t("ul",[t("li",[i._v("git log --all")]),t("li",[i._v("git log --all --graph")])])])])])])]),t("li",[t("p",[i._v("比较 diff")]),t("ul",[t("li",[t("p",[i._v("比较具体的两次 commit")]),t("ul",[t("li",[i._v("git diff commithash1  commitxxxhash2")])])]),t("li",[t("p",[i._v("比较暂存区和上一次提交状态（HEAD）  之间的区别")]),t("ul",[t("li",[i._v("git diff --cached")])])]),t("li",[t("p",[i._v("比较的是 工作区和暂存区的区别")]),t("ul",[t("li",[t("p",[i._v("git diff")]),t("ul",[t("li",[i._v("git diff -- readme.md ")])])])])]),t("li",[t("p",[i._v("指代 commit")]),t("ul",[t("li",[t("p",[i._v("git diff HEAD HEAD^")]),t("ul",[t("li",[i._v("比较上次提交 和 上上次提交的差异")])])]),t("li",[t("p",[i._v("git diff HEAD HEAD^^")]),t("ul",[t("li",[i._v("比较上次提交  和 上上上次提交的差异")])])])])]),t("li",[t("p",[i._v("比较两个分支之间的区别")]),t("ul",[t("li",[t("p",[i._v("git diff  master temp")])]),t("li",[t("p",[i._v("git diff master temp -- index.html")])]),t("li",[t("p",[i._v("git diff ce9a7907 d7d5dbd -- index.html ")]),t("ul",[t("li",[i._v("对不同分支上的不同 commit 的提交 做比较")])])])])])])]),t("li",[t("p",[i._v("变更")]),t("ul",[t("li",[t("p",[i._v("reset")]),t("ul",[t("li",[t("p",[i._v("改暂存区")]),t("ul",[t("li",[t("p",[i._v("把暂存区 恢复成 HEAD")]),t("ul",[t("li",[t("p",[i._v("git reset HEAD")]),t("ul",[t("li",[i._v("git diff --cached")])])]),t("li",[t("p",[i._v("git reset HEAD -- readme.md index.html")])])])]),t("li",[t("p",[i._v("恢复到某一次 commit")]),t("ul",[t("li",[i._v("git reset --hard commitId")])])])])])])]),t("li",[t("p",[i._v("checkout")]),t("ul",[t("li",[t("p",[i._v("改工作区")]),t("ul",[t("li",[t("p",[i._v("把工作区内容 恢复成  暂存区")]),t("ul",[t("li",[i._v("git checkout -- index.html")])])])])])])])])]),t("li",[t("p",[i._v("临时存储")]),t("ul",[t("li",[t("p",[i._v("存储")]),t("ul",[t("li",[i._v("git stash")])])]),t("li",[t("p",[i._v("从 存储 中取出放到工作区 + 存储信息保留 可以反复使用")]),t("ul",[t("li",[i._v("git stash apply")])])]),t("li",[t("p",[i._v("从 存储 中取出放到工作区 + 存储信息出栈  无法找到原有的记录")]),t("ul",[t("li",[i._v("git stash pop")])])]),t("li",[t("p",[i._v("git stash list")]),t("ul",[t("li",[i._v("查看 堆栈")])])])])]),t("li",[t("p",[i._v("hash 值长短问题")]),t("ul",[t("li",[i._v("只要 hash 值足够说明唯一性，即可")])])]),t("li",[t("p",[i._v("删除文件")]),t("ul",[t("li",[t("p",[i._v("git rm readme.md")]),t("ul",[t("li",[i._v("把文件 从工作区删除 并在暂存区 也删除")])])])])]),t("li",[t("p",[i._v(".gitignore")]),t("ul",[t("li",[t("p",[i._v("abc")]),t("ul",[t("li",[i._v("文件名是 abc 和 abc 文件夹下的内容  都不放入 git版本库")])])]),t("li",[t("p",[i._v("abc/")]),t("ul",[t("li",[i._v("git 只管理 abc 文件夹下的文件")])])])])]),t("li",[t("p",[i._v("git 仓库的备份")]),t("ul",[t("li",[t("p",[i._v("传输协议")]),t("ul",[t("li",[t("p",[i._v("本地协议")]),t("ul",[t("li",[t("p",[i._v("哑协议")]),t("ul",[t("li",[i._v("/path/to/repo.git")])])]),t("li",[t("p",[i._v("智能协议")]),t("ul",[t("li",[i._v("file:///path/to/repo.git")])])])])]),t("li",[t("p",[i._v("http / https")]),t("ul",[t("li",[t("a",{staticClass:"url",attrs:{href:"http://git-server.com:port/path/to/repo.git",target:"_blank"}},[i._v("http://git-server.com:port/path/to/repo.git")])])])]),t("li",[t("p",[i._v("ssh 协议")]),t("ul",[t("li",[t("a",{staticClass:"url",attrs:{href:"mailto:user@git-server.com",target:"_blank"}},[i._v("user@git-server.com")]),i._v(":path/to/repo.git")])])])])])])])]),t("h3",[i._v("分支操作")]),t("ul",[t("li",[t("p",[i._v("查看本地分支")]),t("ul",[t("li",[i._v("git branch -v")])])]),t("li",[t("p",[i._v("分离头指针(detached HEAD)")]),t("ul",[t("li",[i._v("即当前变更 未跟任何的分支挂钩")]),t("li",[i._v("切换到别的分支时，若不与某个分支挂钩，可能会被 git 当成辣鸡清除")])])]),t("li",[t("p",[i._v("删除分支")]),t("ul",[t("li",[i._v("git branch -D db6964b")])])])]),t("h2",[i._v("Git流程梳理与理解 ")]),t("h3",[i._v("Git的四个区域")]),t("ul",[t("li",[t("p",[i._v("工作区")]),t("ul",[t("li",[i._v("本地电脑存放项目文件的地方，比如learnGitProject文件夹；")])])]),t("li",[t("p",[i._v("暂存区（Index/Stage）")]),t("ul",[t("li",[i._v("在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；")])])]),t("li",[t("p",[i._v("本地仓库")]),t("ul",[t("li",[i._v(".git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；")])])]),t("li",[t("p",[i._v("远程仓库")]),t("ul",[t("li",[i._v("不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；")])])])]),t("h3",[i._v("git工作区、暂存区和版本库")]),t("ul",[t("li",[t("p",[i._v("图示")]),t("ul",[t("li",[t("p",[i._v("工作区")]),t("p",[i._v("工作区：就是你在电脑里能看到的目录。")])]),t("li",[t("p",[i._v("暂存区")]),t("p",[i._v('暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。')])]),t("li",[t("p",[i._v("版本库")]),t("p",[i._v("版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。")])]),t("li",[t("p",[i._v("子主题 4")])])])])]),t("h3",[i._v("Git常用操作命令")]),t("ul",[t("li",[t("p",[i._v("工作区上的操作命令")]),t("ul",[t("li",[t("p",[i._v("新建仓库")]),t("ul",[t("li",[t("p",[i._v("（1）将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：git init；")])]),t("li",[t("p",[i._v("（2）从远程git仓库复制项目：git clone  url ")]),t("ul",[t("li",[i._v("克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名：git clone git://github.com/wasd/example.git mygit")])])])])]),t("li",[t("p",[i._v("提交")]),t("ul",[t("li",[t("p",[i._v("（1）提交工作区所有文件到暂存区")]),t("ul",[t("li",[i._v("git add .")])])]),t("li",[t("p",[i._v("（2）提交工作区中指定文件到暂存区")]),t("ul",[t("li",[i._v("git add  file1   file2  ...")])])]),t("li",[t("p",[i._v("（3）提交工作区中某个文件夹中所有文件到暂存区")]),t("ul",[t("li",[i._v("git add [dir]")])])])])]),t("li",[t("p",[i._v("撤销")]),t("ul",[t("li",[t("p",[i._v("（1）删除工作区文件，并且也从暂存区删除对应文件的记录")]),t("ul",[t("li",[i._v("git rm  file1 file2 ")])])]),t("li",[t("p",[i._v("（2）从暂存区中删除文件，但是工作区依然还有该文件")]),t("ul",[t("li",[i._v("git rm --cached file")])])]),t("li",[t("p",[i._v("（3）取消暂存区已经暂存的文件")]),t("ul",[t("li",[i._v("git reset HEAD file...")])])]),t("li",[t("p",[i._v("（4）撤销上一次对文件的操作")]),t("ul",[t("li",[i._v("git checkout --file。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理")])])])])]),t("li",[t("p",[i._v("更新文件")]),t("ul",[t("li",[t("p",[i._v("重命名文件，并将已改名文件提交到暂存区")]),t("ul",[t("li",[i._v("git mv [file-original] [file-renamed]")])])])])]),t("li",[t("p",[i._v("查新信息")]),t("ul",[t("li",[t("p",[i._v("（1）查询当前工作区所有文件的状态")]),t("ul",[t("li",[i._v("git status")])])]),t("li",[t("p",[i._v("（2）比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较")]),t("ul",[t("li",[i._v("git diff [file-name]")])])])])])])]),t("li",[t("p",[i._v("暂存区上的操作命令")]),t("ul",[t("li",[t("p",[i._v("提交文件到版本库")]),t("ul",[t("li",[t("p",[i._v("（1）将暂存区中的文件提交到本地仓库中，即打上新版本")]),t("ul",[t("li",[i._v('git commit -m "commit_info"')])])]),t("li",[t("p",[i._v("（2）将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程")]),t("ul",[t("li",[i._v('git commit -a -m "commit_info"')])])]),t("li",[t("p",[i._v("（3）提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交")]),t("ul",[t("li",[i._v("git commit --amend")])])])])]),t("li",[t("p",[i._v("查看信息")]),t("ul",[t("li",[t("p",[i._v("（1）比较暂存区与上一版本的差异")]),t("ul",[t("li",[i._v("git diff --cached")])])]),t("li",[t("p",[i._v("（2）指定文件在暂存区和本地仓库的不同")]),t("ul",[t("li",[i._v("git diff [file-name] --cached")])])]),t("li",[t("p",[i._v("（3）查看提交历史")]),t("ul",[t("li",[i._v("git log；参数-p展开每次提交的内容差异，用-2显示最近的两次更新，如git log -p -2;")])])])])]),t("li",[t("p",[i._v("分支管理")]),t("ul",[t("li",[t("p",[i._v("创建与合并分支")]),t("ul",[t("li",[t("p",[i._v("（1）查看分支")]),t("ul",[t("li",[i._v("git branch")])])]),t("li",[t("p",[i._v("（2）创建分支")]),t("ul",[t("li",[i._v("git branch [name]")])])]),t("li",[t("p",[i._v("（3）切换分支")]),t("ul",[t("li",[i._v("git checkout [name]")])])]),t("li",[t("p",[i._v("（4）创建+切换分支")]),t("ul",[t("li",[i._v("git checkout -b [name]")])])]),t("li",[t("p",[i._v("（5）合并某分支到当前分支")]),t("ul",[t("li",[i._v("git merge [name]")])])]),t("li",[t("p",[i._v("（6）删除分支")]),t("ul",[t("li",[i._v("git branch -d [name]")])])])])]),t("li",[t("p",[i._v("解决冲突")]),t("ul",[t("li",[i._v('当一个分支与另一个分支有冲突时，如使用merge语句进行合并，那么则需要手动解决冲突，git status也可以告诉我们冲突的文件，Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后提交：$ git add readme.txt \n$ git commit -m "conflict fixed"，最后，删除feature1分支：$ git branch -d feature1')])])]),t("li",[t("p",[i._v("BUG分支")]),t("ul",[t("li",[i._v("修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；")]),t("li",[i._v("当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。")])])]),t("li",[t("p",[i._v("Feature分支")]),t("ul",[t("li",[i._v("开发一个新feature，最好新建一个分支；")]),t("li",[i._v("如果要丢弃一个没有被合并过的分支，可以通过git branch -D [name]强行删除。")])])]),t("li",[t("p",[i._v("多人协作")]),t("ul",[t("li",[t("p",[i._v("（1）首先，可以试图用git push origin [branch-name]推送自己的修改；")])]),t("li",[t("p",[i._v("（2）如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；")])]),t("li",[t("p",[i._v("（3）如果合并有冲突，则解决冲突，并在本地提交；")])]),t("li",[t("p",[i._v("（4）没有冲突或者解决掉冲突后，再用git push origin [branch-name]推送就能成功！")])]),t("li",[t("p",[i._v("如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to [branch-name] origin/[branch-name]。")])]),t("li",[t("p",[i._v("小结")]),t("ul",[t("li",[i._v("查看远程库信息，使用git remote -v；")]),t("li",[i._v("本地新建的分支如果不推送到远程，对其他人就是不可见的；")]),t("li",[i._v("从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；")]),t("li",[i._v("在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；")]),t("li",[i._v("建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；")]),t("li",[i._v("从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。")])])]),t("li",[t("p",[i._v("示例")]),t("ul",[t("li",[i._v("【成员一： 初始仓库操作】")]),t("li",[i._v("【成员一： 建立dev分支操作】")]),t("li",[i._v("【成员二：改动dev分支操作】")]),t("li",[i._v("【成员一：之后再改动dev分支】")])])])])])])]),t("li",[t("p",[i._v("复杂分支操作")]),t("ul",[t("li",[t("p",[i._v("（1）把远程分支合并到当前分支")]),t("ul",[t("li",[i._v("git merge [remote-name]/[branch-name]，如git merge origin/serverfix；")]),t("li",[i._v("如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；")])])]),t("li",[t("p",[i._v("（2）在远程分支的基础上创建新的本地分支")]),t("ul",[t("li",[i._v("git checkout -b [branch-name] [remote-name]/[branch-name]，如git checkout -b serverfix origin/serverfix;")])])]),t("li",[t("p",[i._v("（3）从远程分支checkout出来的本地分支，称之为跟踪分支。")]),t("ul",[t("li",[i._v("在跟踪分支上向远程分支上推送内容：git push。该命令会自动判断应该向远程仓库中的哪个分支推送数据")]),t("li",[i._v("在跟踪分支上合并远程分支：git pull")])])]),t("li",[t("p",[i._v("（4）将一个分支里提交的改变移到基底分支上重放一遍")]),t("ul",[t("li",[i._v("git rebase [rebase-branch] [branch-name]，如git rebase master server；将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；")]),t("li",[i._v("如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用--onto操作：git rebase --onto [rebase-branch]  [feature branch] [sub-feature-branch]，如git rebase --onto master server client；")]),t("li",[i._v("使用rebase操作应该遵循的原则是：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作；")])])])])])])]),t("li",[t("p",[i._v("本地仓库上的操作")]),t("ul",[t("li",[t("p",[i._v("查看本地仓库关联的远程仓库")]),t("ul",[t("li",[i._v("git remote -v")]),t("li",[i._v("在克隆完每个远程仓库后，远程仓库默认为origin;加上-v的参数后，会显示远程仓库的url地址；")])])]),t("li",[t("p",[i._v("为本地仓库添加远程关联仓库，一般会取一个简短的别名")]),t("ul",[t("li",[t("p",[i._v("git remote add [remote-name] [url]，比如：git remote add example git://github.com/example/example.git;")]),t("ul",[t("li",[i._v("不过一般都起 origin")])])]),t("li",[t("p",[i._v("了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。")])])])]),t("li",[t("p",[i._v("将本地仓库某分支推送到远程仓库上")]),t("ul",[t("li",[t("p",[i._v("git push [remote-name] [branch-name]，如git push origin master")]),t("ul",[t("li",[i._v("git push -u origin master第一次从本地仓库推送空的远程仓库时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。")])])]),t("li",[t("p",[i._v("如果想将本地分支推送到远程仓库的不同名分支")]),t("ul",[t("li",[i._v("git push  remote-name   local-branch : remote-branch ，如git push origin serverfix:awesomebranch")])])]),t("li",[t("p",[i._v("如果想删除远程分支")]),t("ul",[t("li",[i._v("git push [romote-name] : remote-branch ，如git push origin :serverfix。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。")])])])])]),t("li",[t("p",[i._v("从远程仓库中抓取本地仓库中没有的更新")]),t("ul",[t("li",[i._v("git fetch [remote-name]，如git fetch origin")]),t("li",[i._v("使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。（只更新了commit id，git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。）如果设置了某个分支关联到远程仓库的某个分支的话，可以使用git pull来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；")])])]),t("li",[t("p",[i._v("查看远程仓库的详细信息")]),t("ul",[t("li",[i._v("git remote show origin")])])]),t("li",[t("p",[i._v("版本回退")]),t("ul",[t("li",[t("p",[i._v("在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。")]),t("ul",[t("li",[i._v("git reset --hard HEAD^")])])]),t("li",[t("p",[i._v("回到未来")]),t("ul",[t("li",[i._v("git reset --hard 1094a （可使用git reflog来查看commit ID）")])])])])])])])]),t("h3",[i._v("忽略文件.gitignore")]),t("ul",[t("li",[i._v("一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。")])]),t("p",[t("em",[i._v("XMind: ZEN - Trial Version")])])])}],_={},g=_,p=t("2877"),u=Object(p["a"])(g,v,e,!1,null,"6b0bf3de",null);l["default"]=u.exports}}]);